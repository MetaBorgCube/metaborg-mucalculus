module remove_negation

imports

  pp
  util
  nabl2/api
  signatures/mucalculus-sig

strategies

  editor_remove_negation = editor-action-prettyprinted(remove_negation ; pp-debug | "Unnegated")

  remove_negation = topdown(try(unnegate))
  
rules

  //remove negations by moving them inwards
  unnegate: Negation(True()) -> False()
  unnegate: Negation(False()) -> True()
  
  unnegate: Negation(Negation(f)) -> f
  
  unnegate: Negation(And(f, g)) -> Or(Negation(f), Negation(g))
  unnegate: Negation(Or(f, g)) -> And(Negation(f), Negation(g))
  
  unnegate: Negation(Diamond(a, f)) -> Box(a, Negation(f))
  unnegate: Negation(Box(a, f)) -> Diamond(a, Negation(f))
  
  unnegate: Negation(Mu(v, f)) -> Nu(v, Negation(g))
  with (g) := <alltd(negate_var(|v))> (f)
  unnegate: Negation(Nu(v, f)) -> Mu(v, Negation(g))
  with (g) := <alltd(negate_var(|v))> (f)
  
  unnegate: Negation(Nest(f)) -> Nest(Negation(f))
  
  negate_var(|v): Var(w) -> Negation(Var(w))
  where <eq>(<strip-annos> v, <strip-annos> w)
  
  //each variable must have an even number of negations in its scope
  //this is done by working the negation inwards and then check whether negated variables exist
  nabl2-custom-analysis-unit-hook: (_, ast, _) -> errors*
    with
      error_vars := <remove_negation ; collect-all(?Negation(Var(_))) > ast;
      errors* := <map(\ Negation(n@Var(v)) -> (n, $[Variable [v] has an uneven number of negations in its scope]) \)> error_vars

  nabl2-custom-analysis-final-hook(|a): (_, _, custom-unit-results) -> (errors*, warnings*, notes*, [])
    with
      errors*   := <flatten-list> custom-unit-results;
      warnings* := [];
      notes*    := []
